From f4fce0ba4e7c95b7cf61320b21e53d119f115181 Mon Sep 17 00:00:00 2001
From: Lovin Yarn <juanshengyuan@gmail.com>
Date: Tue, 11 Nov 2025 04:03:52 +0800
Subject: [PATCH] 1

---
 Makefile                                      |  16 +-
 ...port-extroot-for-non-MTD-rootfs_data.patch | 132 ++++++++
 ...-tiny-add-support-for-XFS-superblock.patch | 314 ++++++++++++++++++
 patches/0003-block-add-xfsck-support.patch    |  28 ++
 ...04-fstools-use-ntfs3-instead-of-ntfs.patch |  77 +++++
 patches/0005-block-remove-invalid-logs.patch  |  30 ++
 6 files changed, 588 insertions(+), 9 deletions(-)
 create mode 100644 patches/0001-fstools-support-extroot-for-non-MTD-rootfs_data.patch
 create mode 100644 patches/0002-libblkid-tiny-add-support-for-XFS-superblock.patch
 create mode 100644 patches/0003-block-add-xfsck-support.patch
 create mode 100644 patches/0004-fstools-use-ntfs3-instead-of-ntfs.patch
 create mode 100644 patches/0005-block-remove-invalid-logs.patch

diff --git a/Makefile b/Makefile
index 7a31673..cb79a09 100644
--- a/Makefile
+++ b/Makefile
@@ -93,12 +93,16 @@ define Package/blockd
 endef
 
 define Package/fstools/install
-	$(INSTALL_DIR) $(1)/sbin $(1)/lib
-
+	$(INSTALL_DIR) $(1)/sbin $(1)/lib $(1)/usr/sbin
 	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/{mount_root,factoryreset} $(1)/sbin/
 	$(INSTALL_DATA) $(PKG_INSTALL_DIR)/usr/lib/libfstools.so $(1)/lib/
+	$(INSTALL_DATA) $(PKG_INSTALL_DIR)/usr/lib/libblkid-tiny.so $(1)/lib/
 	$(LN) factoryreset $(1)/sbin/jffs2mark
 	$(LN) factoryreset $(1)/sbin/jffs2reset
+
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/block $(1)/sbin/
+	$(LN) ../../sbin/block $(1)/usr/sbin/swapon
+	$(LN) ../../sbin/block $(1)/usr/sbin/swapoff
 endef
 
 define Package/snapshot-tool/install
@@ -109,18 +113,12 @@ define Package/snapshot-tool/install
 endef
 
 define Package/block-mount/install
-	$(INSTALL_DIR) $(1)/sbin $(1)/lib $(1)/usr/sbin $(1)/etc/hotplug.d/block $(1)/etc/init.d/ $(1)/etc/uci-defaults/
+	$(INSTALL_DIR) $(1)/etc/hotplug.d/block $(1)/etc/init.d/ $(1)/etc/uci-defaults/
 
 	$(INSTALL_BIN) ./files/fstab.init $(1)/etc/init.d/fstab
 	$(INSTALL_CONF) ./files/fstab.default $(1)/etc/uci-defaults/10-fstab
 	$(INSTALL_CONF) ./files/mount.hotplug $(1)/etc/hotplug.d/block/10-mount
 	$(INSTALL_CONF) ./files/media-change.hotplug  $(1)/etc/hotplug.d/block/00-media-change
-
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/block $(1)/sbin/
-	$(INSTALL_DATA) $(PKG_INSTALL_DIR)/usr/lib/libblkid-tiny.so $(1)/lib/
-	$(LN) ../../sbin/block $(1)/usr/sbin/swapon
-	$(LN) ../../sbin/block $(1)/usr/sbin/swapoff
-
 endef
 
 define Package/blockd/install
diff --git a/patches/0001-fstools-support-extroot-for-non-MTD-rootfs_data.patch b/patches/0001-fstools-support-extroot-for-non-MTD-rootfs_data.patch
new file mode 100644
index 0000000..6f80907
--- /dev/null
+++ b/patches/0001-fstools-support-extroot-for-non-MTD-rootfs_data.patch
@@ -0,0 +1,132 @@
+From a77bf10b29ae699fd306cb94af0f00d375ab5eae Mon Sep 17 00:00:00 2001
+From: Qi Liu <liuqi_colin@msn.com>
+Date: Sat, 5 Oct 2024 20:22:44 +0800
+Subject: [PATCH 1/4] fstools: support extroot for non-MTD rootfs_data
+
+In order to support extroot, block extroot command has to
+ be able to discover and properly mount the rootfs_data volume in order to
+ discover the extroot volume. Currently this process can only discover MTD
+ devices. This patch leverages libfstools in a similar way as mount_root to
+ discover, initialize, and mount rootfs_data volume. It would enable any
+ device with non-MTD rootfs_data volume to support extroot, including x86.
+
+Signed-off-by: Qi Liu <liuqi_colin@msn.com>
+---
+ CMakeLists.txt          |  4 ++--
+ block.c                 | 40 ++++++++++++++++++++++++++++++++++++++++
+ libfstools/fstype.h     | 13 +++++++++++++
+ libfstools/libfstools.h | 12 +-----------
+ 4 files changed, 56 insertions(+), 13 deletions(-)
+ create mode 100644 libfstools/fstype.h
+
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -80,9 +80,9 @@ INSTALL(TARGETS blockd RUNTIME DESTINATI
+ ADD_EXECUTABLE(block block.c probe.c probe-libblkid.c)
+ IF(DEFINED CMAKE_UBIFS_EXTROOT)
+ 	ADD_DEFINITIONS(-DUBIFS_EXTROOT)
+-	TARGET_LINK_LIBRARIES(block blkid-tiny dl uci ubox ubus blobmsg_json ubi-utils ${json})
++	TARGET_LINK_LIBRARIES(block fstools blkid-tiny dl uci ubox ubus blobmsg_json ubi-utils ${json})
+ ELSE(DEFINED CMAKE_UBIFS_EXTROOT)
+-	TARGET_LINK_LIBRARIES(block blkid-tiny dl uci ubox ubus blobmsg_json ${json})
++	TARGET_LINK_LIBRARIES(block fstools blkid-tiny dl uci ubox ubus blobmsg_json ${json})
+ ENDIF(DEFINED CMAKE_UBIFS_EXTROOT)
+ INSTALL(TARGETS block RUNTIME DESTINATION sbin)
+ 
+--- a/block.c
++++ b/block.c
+@@ -44,6 +44,8 @@
+ #include <libubox/vlist.h>
+ #include <libubus.h>
+ 
++#include "libfstools/fstype.h"
++#include "libfstools/volume.h"
+ #include "probe.h"
+ 
+ #define AUTOFS_MOUNT_PATH       "/tmp/run/blockd/"
+@@ -1714,6 +1716,44 @@ static int main_extroot(int argc, char *
+        }
+ #endif
+ 
++  /* Find volume using libfstools */
++	struct volume *data = volume_find("rootfs_data");
++	if (data) {
++		volume_init(data);
++
++	  switch (volume_identify(data)) {
++		case FS_EXT4: {
++			char cfg[] = "/tmp/ext4_cfg";
++
++			/* Mount volume and try extroot (using fstab from that vol) */
++			mkdir_p(cfg, 0755);
++			if (!mount(data->blk, cfg, "ext4", MS_NOATIME, NULL)) {
++				err = mount_extroot(cfg);
++				umount2(cfg, MNT_DETACH);
++			}
++			if (err < 0)
++				rmdir("/tmp/overlay");
++			rmdir(cfg);
++			return err;
++		}
++
++		case FS_F2FS: {
++			char cfg[] = "/tmp/f2fs_cfg";
++
++			/* Mount volume and try extroot (using fstab from that vol) */
++			mkdir_p(cfg, 0755);
++			if (!mount(data->blk, cfg, "f2fs", MS_NOATIME, NULL)) {
++				err = mount_extroot(cfg);
++				umount2(cfg, MNT_DETACH);
++			}
++			if (err < 0)
++				rmdir("/tmp/overlay");
++			rmdir(cfg);
++			return err;
++		}
++		}
++	}
++
+ 	/* As a last resort look for /etc/config/fstab on "rootfs" partition */
+ 	return mount_extroot(NULL);
+ }
+--- /dev/null
++++ b/libfstools/fstype.h
+@@ -0,0 +1,13 @@
++#ifndef _FS_TYPE_H__
++#define _FS_TYPE_H__
++enum {
++	FS_NONE,
++	FS_SNAPSHOT,
++	FS_JFFS2,
++	FS_DEADCODE,
++	FS_UBIFS,
++	FS_F2FS,
++	FS_EXT4,
++	FS_TARGZ,
++};
++#endif
+\ No newline at end of file
+--- a/libfstools/libfstools.h
++++ b/libfstools/libfstools.h
+@@ -18,20 +18,10 @@
+ #include <libubox/blob.h>
+ #include <libubox/ulog.h>
+ #include <libubox/utils.h>
++#include "fstype.h"
+ 
+ struct volume;
+ 
+-enum {
+-	FS_NONE,
+-	FS_SNAPSHOT,
+-	FS_JFFS2,
+-	FS_DEADCODE,
+-	FS_UBIFS,
+-	FS_F2FS,
+-	FS_EXT4,
+-	FS_TARGZ,
+-};
+-
+ enum fs_state {
+ 	FS_STATE_UNKNOWN,
+ 	FS_STATE_PENDING,
diff --git a/patches/0002-libblkid-tiny-add-support-for-XFS-superblock.patch b/patches/0002-libblkid-tiny-add-support-for-XFS-superblock.patch
new file mode 100644
index 0000000..540e663
--- /dev/null
+++ b/patches/0002-libblkid-tiny-add-support-for-XFS-superblock.patch
@@ -0,0 +1,314 @@
+From 3b83493ec7f87020d995203be5fe27cd5757887f Mon Sep 17 00:00:00 2001
+From: sbwml <984419930@qq.com>
+Date: Sat, 28 Jan 2023 19:33:16 +0800
+Subject: [PATCH 2/4] libblkid-tiny: add support for XFS superblock
+
+---
+ CMakeLists.txt                |   1 +
+ libblkid-tiny/libblkid-tiny.c |   2 +
+ libblkid-tiny/xfs.c           | 278 ++++++++++++++++++++++++++++++++++
+ 3 files changed, 281 insertions(+)
+ create mode 100644 libblkid-tiny/xfs.c
+
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -38,6 +38,7 @@ ADD_LIBRARY(blkid-tiny SHARED
+ 		libblkid-tiny/squashfs.c
+ 		libblkid-tiny/btrfs.c
+ 		libblkid-tiny/f2fs.c
++		libblkid-tiny/xfs.c
+ 		)
+ INSTALL(TARGETS blkid-tiny LIBRARY DESTINATION lib)
+ INSTALL(FILES libblkid-tiny/libblkid-tiny.h DESTINATION include)
+--- a/libblkid-tiny/libblkid-tiny.c
++++ b/libblkid-tiny/libblkid-tiny.c
+@@ -189,6 +189,8 @@ static const struct blkid_idinfo *idinfo
+ 	&hfs_idinfo,
+ 	&btrfs_idinfo,
+ 	&f2fs_idinfo,
++	&xfs_idinfo,
++	&xfs_log_idinfo,
+ };
+ 
+ int probe_block(char *block, struct blkid_struct_probe *pr)
+--- /dev/null
++++ b/libblkid-tiny/xfs.c
+@@ -0,0 +1,278 @@
++/*
++ * Copyright (C) 1999 by Andries Brouwer
++ * Copyright (C) 1999, 2000, 2003 by Theodore Ts'o
++ * Copyright (C) 2001 by Andreas Dilger
++ * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
++ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
++ * Copyright (C) 2013 Eric Sandeen <sandeen@redhat.com>
++ *
++ * This file may be redistributed under the terms of the
++ * GNU Lesser General Public License.
++ */
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <unistd.h>
++#include <string.h>
++#include <errno.h>
++#include <ctype.h>
++#include <stdint.h>
++
++#include "superblocks.h"
++
++struct xfs_super_block {
++	uint32_t	sb_magicnum;	/* magic number == XFS_SB_MAGIC */
++	uint32_t	sb_blocksize;	/* logical block size, bytes */
++	uint64_t	sb_dblocks;	/* number of data blocks */
++	uint64_t	sb_rblocks;	/* number of realtime blocks */
++	uint64_t	sb_rextents;	/* number of realtime extents */
++	unsigned char	sb_uuid[16];	/* file system unique id */
++	uint64_t	sb_logstart;	/* starting block of log if internal */
++	uint64_t	sb_rootino;	/* root inode number */
++	uint64_t	sb_rbmino;	/* bitmap inode for realtime extents */
++	uint64_t	sb_rsumino;	/* summary inode for rt bitmap */
++	uint32_t	sb_rextsize;	/* realtime extent size, blocks */
++	uint32_t	sb_agblocks;	/* size of an allocation group */
++	uint32_t	sb_agcount;	/* number of allocation groups */
++	uint32_t	sb_rbmblocks;	/* number of rt bitmap blocks */
++	uint32_t	sb_logblocks;	/* number of log blocks */
++
++	uint16_t	sb_versionnum;	/* header version == XFS_SB_VERSION */
++	uint16_t	sb_sectsize;	/* volume sector size, bytes */
++	uint16_t	sb_inodesize;	/* inode size, bytes */
++	uint16_t	sb_inopblock;	/* inodes per block */
++	char		sb_fname[12];	/* file system name */
++	uint8_t		sb_blocklog;	/* log2 of sb_blocksize */
++	uint8_t		sb_sectlog;	/* log2 of sb_sectsize */
++	uint8_t		sb_inodelog;	/* log2 of sb_inodesize */
++	uint8_t		sb_inopblog;	/* log2 of sb_inopblock */
++	uint8_t		sb_agblklog;	/* log2 of sb_agblocks (rounded up) */
++	uint8_t		sb_rextslog;	/* log2 of sb_rextents */
++	uint8_t		sb_inprogress;	/* mkfs is in progress, don't mount */
++	uint8_t		sb_imax_pct;	/* max % of fs for inode space */
++					/* statistics */
++	uint64_t	sb_icount;	/* allocated inodes */
++	uint64_t	sb_ifree;	/* free inodes */
++	uint64_t	sb_fdblocks;	/* free data blocks */
++	uint64_t	sb_frextents;	/* free realtime extents */
++
++	/* this is not all... but enough for libblkid */
++
++} __attribute__((packed));
++
++#define XFS_MIN_BLOCKSIZE_LOG	9	/* i.e. 512 bytes */
++#define XFS_MAX_BLOCKSIZE_LOG	16	/* i.e. 65536 bytes */
++#define XFS_MIN_BLOCKSIZE	(1 << XFS_MIN_BLOCKSIZE_LOG)
++#define XFS_MAX_BLOCKSIZE	(1 << XFS_MAX_BLOCKSIZE_LOG)
++#define XFS_MIN_SECTORSIZE_LOG	9	/* i.e. 512 bytes */
++#define XFS_MAX_SECTORSIZE_LOG	15	/* i.e. 32768 bytes */
++#define XFS_MIN_SECTORSIZE	(1 << XFS_MIN_SECTORSIZE_LOG)
++#define XFS_MAX_SECTORSIZE	(1 << XFS_MAX_SECTORSIZE_LOG)
++
++#define	XFS_DINODE_MIN_LOG	8
++#define	XFS_DINODE_MAX_LOG	11
++#define	XFS_DINODE_MIN_SIZE	(1 << XFS_DINODE_MIN_LOG)
++#define	XFS_DINODE_MAX_SIZE	(1 << XFS_DINODE_MAX_LOG)
++
++#define	XFS_MAX_RTEXTSIZE	(1024 * 1024 * 1024)	/* 1GB */
++#define	XFS_DFL_RTEXTSIZE	(64 * 1024)	        /* 64kB */
++#define	XFS_MIN_RTEXTSIZE	(4 * 1024)		/* 4kB */
++
++#define XFS_MIN_AG_BLOCKS	64
++#define XFS_MAX_DBLOCKS(s) ((uint64_t)(s)->sb_agcount * (s)->sb_agblocks)
++#define XFS_MIN_DBLOCKS(s) ((uint64_t)((s)->sb_agcount - 1) *	\
++			 (s)->sb_agblocks + XFS_MIN_AG_BLOCKS)
++
++
++static void sb_from_disk(struct xfs_super_block *from,
++			 struct xfs_super_block *to)
++{
++
++	to->sb_magicnum = be32_to_cpu(from->sb_magicnum);
++	to->sb_blocksize = be32_to_cpu(from->sb_blocksize);
++	to->sb_dblocks = be64_to_cpu(from->sb_dblocks);
++	to->sb_rblocks = be64_to_cpu(from->sb_rblocks);
++	to->sb_rextents = be64_to_cpu(from->sb_rextents);
++	to->sb_logstart = be64_to_cpu(from->sb_logstart);
++	to->sb_rootino = be64_to_cpu(from->sb_rootino);
++	to->sb_rbmino = be64_to_cpu(from->sb_rbmino);
++	to->sb_rsumino = be64_to_cpu(from->sb_rsumino);
++	to->sb_rextsize = be32_to_cpu(from->sb_rextsize);
++	to->sb_agblocks = be32_to_cpu(from->sb_agblocks);
++	to->sb_agcount = be32_to_cpu(from->sb_agcount);
++	to->sb_rbmblocks = be32_to_cpu(from->sb_rbmblocks);
++	to->sb_logblocks = be32_to_cpu(from->sb_logblocks);
++	to->sb_versionnum = be16_to_cpu(from->sb_versionnum);
++	to->sb_sectsize = be16_to_cpu(from->sb_sectsize);
++	to->sb_inodesize = be16_to_cpu(from->sb_inodesize);
++	to->sb_inopblock = be16_to_cpu(from->sb_inopblock);
++	to->sb_blocklog = from->sb_blocklog;
++	to->sb_sectlog = from->sb_sectlog;
++	to->sb_inodelog = from->sb_inodelog;
++	to->sb_inopblog = from->sb_inopblog;
++	to->sb_agblklog = from->sb_agblklog;
++	to->sb_rextslog = from->sb_rextslog;
++	to->sb_inprogress = from->sb_inprogress;
++	to->sb_imax_pct = from->sb_imax_pct;
++	to->sb_icount = be64_to_cpu(from->sb_icount);
++	to->sb_ifree = be64_to_cpu(from->sb_ifree);
++	to->sb_fdblocks = be64_to_cpu(from->sb_fdblocks);
++	to->sb_frextents = be64_to_cpu(from->sb_frextents);
++}
++
++static int xfs_verify_sb(struct xfs_super_block *ondisk)
++{
++	struct xfs_super_block sb, *sbp = &sb;
++
++	/* beXX_to_cpu(), but don't convert UUID and fsname! */
++	sb_from_disk(ondisk, sbp);
++
++	/* sanity checks, we don't want to rely on magic string only */
++	if (sbp->sb_agcount <= 0					||
++	    sbp->sb_sectsize < XFS_MIN_SECTORSIZE			||
++	    sbp->sb_sectsize > XFS_MAX_SECTORSIZE			||
++	    sbp->sb_sectlog < XFS_MIN_SECTORSIZE_LOG			||
++	    sbp->sb_sectlog > XFS_MAX_SECTORSIZE_LOG			||
++	    sbp->sb_sectsize != (1 << sbp->sb_sectlog)			||
++	    sbp->sb_blocksize < XFS_MIN_BLOCKSIZE			||
++	    sbp->sb_blocksize > XFS_MAX_BLOCKSIZE			||
++	    sbp->sb_blocklog < XFS_MIN_BLOCKSIZE_LOG			||
++	    sbp->sb_blocklog > XFS_MAX_BLOCKSIZE_LOG			||
++	    sbp->sb_blocksize != (1ULL << sbp->sb_blocklog)		||
++	    sbp->sb_inodesize < XFS_DINODE_MIN_SIZE			||
++	    sbp->sb_inodesize > XFS_DINODE_MAX_SIZE			||
++	    sbp->sb_inodelog < XFS_DINODE_MIN_LOG			||
++	    sbp->sb_inodelog > XFS_DINODE_MAX_LOG			||
++	    sbp->sb_inodesize != (1 << sbp->sb_inodelog)		||
++	    (sbp->sb_blocklog - sbp->sb_inodelog != sbp->sb_inopblog)	||
++	    (sbp->sb_rextsize * sbp->sb_blocksize > XFS_MAX_RTEXTSIZE)	||
++	    (sbp->sb_rextsize * sbp->sb_blocksize < XFS_MIN_RTEXTSIZE)	||
++	    (sbp->sb_imax_pct > 100 /* zero sb_imax_pct is valid */)	||
++	    sbp->sb_dblocks == 0					||
++	    sbp->sb_dblocks > XFS_MAX_DBLOCKS(sbp)			||
++	    sbp->sb_dblocks < XFS_MIN_DBLOCKS(sbp))
++		return 0;
++
++	/* TODO: version 5 has also checksum CRC32, maybe we can check it too */
++
++	return 1;
++}
++
++static int probe_xfs(blkid_probe pr, const struct blkid_idmag *mag)
++{
++	struct xfs_super_block *xs;
++
++	xs = blkid_probe_get_sb(pr, mag, struct xfs_super_block);
++	if (!xs)
++		return errno ? -errno : 1;
++
++	if (!xfs_verify_sb(xs))
++		return 1;
++
++	if (*xs->sb_fname != '\0')
++		blkid_probe_set_label(pr, (unsigned char *) xs->sb_fname,
++				sizeof(xs->sb_fname));
++	blkid_probe_set_uuid(pr, xs->sb_uuid);
++	return 0;
++}
++
++const struct blkid_idinfo xfs_idinfo =
++{
++	.name		= "xfs",
++	.usage		= BLKID_USAGE_FILESYSTEM,
++	.probefunc	= probe_xfs,
++	.magics		=
++	{
++		{ .magic = "XFSB", .len = 4 },
++		{ NULL }
++	}
++};
++
++struct xlog_rec_header {
++	uint32_t	h_magicno;
++	uint32_t	h_dummy1[1];
++	uint32_t	h_version;
++	uint32_t	h_len;
++	uint32_t	h_dummy2[71];
++	uint32_t	h_fmt;
++	unsigned char	h_uuid[16];
++} __attribute__((packed));
++
++#define XLOG_HEADER_MAGIC_NUM 0xFEEDbabe
++
++/*
++ * For very small filesystems, the minimum log size
++ * can be smaller, but that seems vanishingly unlikely
++ * when used with an external log (which is used for
++ * performance reasons; tiny conflicts with that goal).
++ */
++#define XFS_MIN_LOG_BYTES	(10 * 1024 * 1024)
++
++#define XLOG_FMT_LINUX_LE	1
++#define XLOG_FMT_LINUX_BE	2
++#define XLOG_FMT_IRIX_BE	3
++
++#define XLOG_VERSION_1		1
++#define XLOG_VERSION_2		2	/* Large IClogs, Log sunit */
++#define XLOG_VERSION_OKBITS	(XLOG_VERSION_1 | XLOG_VERSION_2)
++
++static int xlog_valid_rec_header(struct xlog_rec_header *rhead)
++{
++	uint32_t hlen;
++
++	if (rhead->h_magicno != cpu_to_be32(XLOG_HEADER_MAGIC_NUM))
++		return 0;
++
++	if (!rhead->h_version ||
++            (be32_to_cpu(rhead->h_version) & (~XLOG_VERSION_OKBITS)))
++		return 0;
++
++	/* LR body must have data or it wouldn't have been written */
++	hlen = be32_to_cpu(rhead->h_len);
++	if (hlen <= 0 || hlen > INT_MAX)
++		return 0;
++
++	if (rhead->h_fmt != cpu_to_be32(XLOG_FMT_LINUX_LE) &&
++	    rhead->h_fmt != cpu_to_be32(XLOG_FMT_LINUX_BE) &&
++	    rhead->h_fmt != cpu_to_be32(XLOG_FMT_IRIX_BE))
++		return 0;
++
++	return 1;
++}
++
++/* xlog record header will be in some sector in the first 256k */
++static int probe_xfs_log(blkid_probe pr,
++		const struct blkid_idmag *mag __attribute__((__unused__)))
++{
++	int i;
++	struct xlog_rec_header *rhead;
++	unsigned char *buf;
++
++	buf = blkid_probe_get_buffer(pr, 0, 256*1024);
++	if (!buf)
++		return errno ? -errno : 1;
++
++	if (memcmp(buf, "XFSB", 4) == 0)
++		return 1;			/* this is regular XFS, ignore */
++
++	/* check the first 512 512-byte sectors */
++	for (i = 0; i < 512; i++) {
++		rhead = (struct xlog_rec_header *)&buf[i*512];
++
++		if (xlog_valid_rec_header(rhead)) {
++			blkid_probe_set_uuid_as(pr, rhead->h_uuid, "LOGUUID");
++			return 0;
++		}
++	}
++
++	return 1;
++}
++
++const struct blkid_idinfo xfs_log_idinfo =
++{
++	.name		= "xfs_external_log",
++	.usage		= BLKID_USAGE_OTHER,
++	.probefunc	= probe_xfs_log,
++	.magics		= BLKID_NONE_MAGIC,
++	.minsz		= XFS_MIN_LOG_BYTES,
++};
diff --git a/patches/0003-block-add-xfsck-support.patch b/patches/0003-block-add-xfsck-support.patch
new file mode 100644
index 0000000..f608103
--- /dev/null
+++ b/patches/0003-block-add-xfsck-support.patch
@@ -0,0 +1,28 @@
+From 70aff01d2fbd8a81b9d275ad48216f7a6bc91e57 Mon Sep 17 00:00:00 2001
+From: sbwml <984419930@qq.com>
+Date: Sat, 28 Jan 2023 20:31:55 +0800
+Subject: [PATCH 3/4] block: add xfsck support
+
+---
+ block.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/block.c
++++ b/block.c
+@@ -767,6 +767,7 @@ static void check_filesystem(struct prob
+ 	const char *e2fsck = "/usr/sbin/e2fsck";
+ 	const char *f2fsck = "/usr/sbin/fsck.f2fs";
+ 	const char *fatfsck = "/usr/sbin/fsck.fat";
++	const char *xfsck = "/usr/sbin/xfs_repair";
+ 	const char *btrfsck = "/usr/bin/btrfsck";
+ 	const char *ntfsck = "/usr/bin/ntfsfix";
+ 	const char *ckfs;
+@@ -779,6 +780,8 @@ static void check_filesystem(struct prob
+ 		ckfs = fatfsck;
+ 	} else if (!strncmp(pr->type, "f2fs", 4)) {
+ 		ckfs = f2fsck;
++	} else if (!strncmp(pr->type, "xfs", 3)) {
++		ckfs = xfsck;
+ 	} else if (!strncmp(pr->type, "ext", 3)) {
+ 		ckfs = e2fsck;
+ 	} else if (!strncmp(pr->type, "btrfs", 5)) {
diff --git a/patches/0004-fstools-use-ntfs3-instead-of-ntfs.patch b/patches/0004-fstools-use-ntfs3-instead-of-ntfs.patch
new file mode 100644
index 0000000..0f5c673
--- /dev/null
+++ b/patches/0004-fstools-use-ntfs3-instead-of-ntfs.patch
@@ -0,0 +1,77 @@
+From 52d6ec22f7b6678a0d7e7ec18e9c72892cd21681 Mon Sep 17 00:00:00 2001
+From: sbwml <admin@cooluc.com>
+Date: Sat, 5 Oct 2024 20:26:55 +0800
+Subject: [PATCH 4/4] fstools: use ntfs3 instead of ntfs
+
+Signed-off-by: sbwml <admin@cooluc.com>
+---
+ block.c              | 16 ++++++++++------
+ libblkid-tiny/ntfs.c |  2 +-
+ 2 files changed, 11 insertions(+), 7 deletions(-)
+
+--- a/block.c
++++ b/block.c
+@@ -786,7 +786,7 @@ static void check_filesystem(struct prob
+ 		ckfs = e2fsck;
+ 	} else if (!strncmp(pr->type, "btrfs", 5)) {
+ 		ckfs = btrfsck;
+-	} else if (!strncmp(pr->type, "ntfs", 4)) {
++	} else if (!strncmp(pr->type, "ntfs3", 4)) {
+ 		ckfs = ntfsck;
+ 	} else {
+ 		ULOG_ERR("check_filesystem: %s is not supported\n", pr->type);
+@@ -806,7 +806,7 @@ static void check_filesystem(struct prob
+ 		} else if(!strncmp(pr->type, "btrfs", 5)) {
+ 			execl(ckfs, ckfs, "--repair", pr->dev, NULL);
+ 			exit(EXIT_FAILURE);
+-		} else if(!strncmp(pr->type, "ntfs", 4)) {
++		} else if(!strncmp(pr->type, "ntfs3", 4)) {
+ 			execl(ckfs, ckfs, "-b", pr->dev, NULL);
+ 			exit(EXIT_FAILURE);
+ 		} else {
+@@ -951,8 +951,12 @@ static int handle_mount(const char *sour
+ 	int err = -EINVAL;
+ 	size_t count;
+ 	int i;
++	char _data[128] = {0};
++	if (strstr(fstype, "fat") || strstr(fstype, "ntfs3")) {
++		snprintf(_data, sizeof(_data), "%s", "iocharset=utf8,uid=65534,gid=65534");
++	}
+ 
+-	if (!strcmp(fstype, "ntfs")) {
++	if (!strcmp(fstype, "ntfs3")) {
+ 		filesystems = ntfs_fs;
+ 		count = ARRAY_SIZE(ntfs_fs);
+ 	} else {
+@@ -964,7 +968,7 @@ static int handle_mount(const char *sour
+ 		const char *fs = filesystems[i];
+ 
+ 		err = mount(source, target, fs, m ? m->flags : 0,
+-			    (m && m->options) ? m->options : "");
++			    (m && m->options) ? m->options : _data);
+ 		if (!err || errno != ENODEV)
+ 			break;
+ 	}
+@@ -1597,9 +1601,9 @@ static int mount_extroot(char *cfg)
+ 		if (strncmp(pr->type, "ext", 3) &&
+ 		    strncmp(pr->type, "f2fs", 4) &&
+ 		    strncmp(pr->type, "btrfs", 5) &&
+-		    strncmp(pr->type, "ntfs", 4) &&
++		    strncmp(pr->type, "ntfs3", 4) &&
+ 		    strncmp(pr->type, "ubifs", 5)) {
+-			ULOG_ERR("extroot: unsupported filesystem %s, try ext4, f2fs, btrfs, ntfs or ubifs\n", pr->type);
++			ULOG_ERR("extroot: unsupported filesystem %s, try ext4, f2fs, btrfs, ntfs3 or ubifs\n", pr->type);
+ 			return -1;
+ 		}
+ 
+--- a/libblkid-tiny/ntfs.c
++++ b/libblkid-tiny/ntfs.c
+@@ -214,7 +214,7 @@ static int probe_ntfs(blkid_probe pr, co
+ 
+ const struct blkid_idinfo ntfs_idinfo =
+ {
+-	.name		= "ntfs",
++	.name		= "ntfs3",
+ 	.usage		= BLKID_USAGE_FILESYSTEM,
+ 	.probefunc	= probe_ntfs,
+ 	.magics		=
diff --git a/patches/0005-block-remove-invalid-logs.patch b/patches/0005-block-remove-invalid-logs.patch
new file mode 100644
index 0000000..4548380
--- /dev/null
+++ b/patches/0005-block-remove-invalid-logs.patch
@@ -0,0 +1,30 @@
+From c47d588d7fdbeaf1d035b797703991c9f7026c7a Mon Sep 17 00:00:00 2001
+From: sbwml <admin@cooluc.com>
+Date: Fri, 18 Oct 2024 21:33:47 +0800
+Subject: [PATCH] block: remove invalid logs
+
+Signed-off-by: sbwml <admin@cooluc.com>
+---
+ block.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/block.c
++++ b/block.c
+@@ -427,7 +427,7 @@ static struct uci_package * config_try_l
+ 
+ 	if (uci_load(ctx, file, &pkg)) {
+ 		uci_get_errorstr(ctx, &err, file);
+-		ULOG_ERR("unable to load configuration (%s)\n", err);
++		//ULOG_ERR("unable to load configuration (%s)\n", err);
+ 
+ 		free(err);
+ 		return NULL;
+@@ -461,7 +461,7 @@ static int config_load(char *cfg)
+ 	}
+ 
+ 	if (!pkg) {
+-		ULOG_ERR("no usable configuration\n");
++		//ULOG_ERR("no usable configuration\n");
+ 		return -1;
+ 	}
+ 
